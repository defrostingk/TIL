# 2022. 05. 02. Mon

### 목차

- [오늘 한 일](#오늘-한-일)

- [진행하면서](#진행하면서)

- [추가 내용](#추가-내용)

- [내일 할 일](#내일-할-일)

- [앞으로 할 일](#앞으로-할-일)

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - greedy 6문제 풀이

### 진행하면서

- 당장 앞에 놓여있는 코딩 테스트를 준비하기 위해 개인 프로젝트는 우선 뒤로 제쳐두고 코딩 테스트에 집중했다.

- greedy 6문제 풀이

  - [대회 or 인턴](https://www.acmicpc.net/problem/2875)

    - 여학생과 남학생의 수를 기준으로 최대로 만들 수 있는 team의 수를 계산하였다. 전체 인원에서 계산한 team의 수를 빼고 internship에 참여해야 하는 학생의 수를 빼 초과되는 인원을 계산하였다. 초과되는 인원은 결성된 team을 해체하여 채워야하므로 그 수만큼 team의 수에서 빼주었다.

  - [30](https://www.acmicpc.net/problem/10610)

    - 30의 배수는 마지막 자리에 0이 오고, 모든 자리의 수를 더하면 3의 배수여야 한다. 구하는 수는 가장 큰 수이므로 주어진 수의 자리를 내림차순으로 정렬한다. 각 자리를 더해 3의 배수가 아니거나, 0을 포함하지 않으면 30의 배수를 만들 수 없으므로 -1을 출력하고 가능한 경우 join을 사용해 모두 이어붙여 출력한다.

  - [병든 나이트](https://www.acmicpc.net/problem/1783)

    - 움직일 수 있는 방법이 제한돼있으므로 체스판의 크기에 따라 고려한다.

    - 체스판의 height가 1이면 움직일 수 없다.

    - 체스판의 height가 2이면 2., 3. 의 방법으로만 움직일 수 있다.

    - 체스판의 height가 3이상이면 모든 방법으로 움직일 수 있다.

      - 단 width가 7인 경우 1., 2., 3., 4.를 모두 사용했을 때 최대 with에 도달하므로 7 미만의 width는 최대 4번 움직일 수 있다.

      - 7 이상의 경우 1., 2., 3., 4.를 모두 사용한 뒤에도 1., 4.를 반복하여 사용할 수 있다.

  - [AB](https://www.acmicpc.net/problem/12970)

    - 각각의 A 우측에 존재하는 B의 개수를 모두 합한 값이 조건을 만족하는 쌍의 개수이다. A의 개수와 B의 개수를 곱한 것이 k보다 작은 경우 조건을 만족할 수 없다. 모든 A가 왼쪽에, 모든 B가 오른쪽에만 존재할 때 만족하는 쌍의 개수가 가장 큰데, 이 값이 A의 개수와 B의 개수의 곱이다.

    - B로만 이루어진 길이 n의 array를 만든다. 가장 오른쪽 원소를 A로 하고 왼쪽에 존재하는 원소와 자리를 바꾸어가며 만족하는 쌍의 개수를 센다. A가 추가될때마다 왼쪽에 존재하는 A의 개수만큼 쌍의 개수가 줄어든다. B가 하나 줄어들어 각각의 A에 대해 만족하는 쌍의 개수가 줄어들기 때문이다.

  - [A와 B](https://www.acmicpc.net/problem/12904)

    - 반대로 생각하면 금방 풀 수 있다. 두 연산 모두 마지막에 원소를 추가하기 때문에 반대로 생각하면 연산 결과에서 마지막 원소를 빼는 것이다. 이때 뺀 원소가 B인 경우 연산 결과를 뒤집는다. 이를 반복하여 S와 T의 길이가 같아졌을 때 두 문자열이 동일하면 1을, 동일하지 않다면 0을 출력한다.

  - [NMK](https://www.acmicpc.net/problem/1201)

    - 1부터 N까지 오름차순으로 정렬된 수열을 M개의 적절한 부분 수열로 나누는 것을 생각해볼 수 있다. 각각의 부분 수열을 다시 내림차순 정렬하면, 각각의 부분수열의 첫번째 원소만을 생각하면 전체 수열에서 가장 긴 증가하는 부분 수열을 이룬다. 첫번째 원소는 부분 수열 내에서 가장 큰 값이므로 다른 원소가 가장 긴 증가하는 부분 수열에 영향을 주지 않는다. 각각의 부분수열은 내림차순으로 정렬하였으므로 가장 긴 감소하는 부분 수열이 될 수 있다. 즉 주어진 조건은 다음과 같이 표현할 수 있다.

      - 가장 긴 감소하는 부분 수열의 길이가 K

        전체 수열은, 최대 K개의 원소를 가지며 적어도 하나는 K개의 원소를 가지는 부분 수열로 이루어진다.

      - 가장 긴 증가하는 부분 수열의 길이가 M

        나뉘어지는 부분 수열의 개수는 M개이다.

      - 가장 긴 감소하는 부분 수열과 가장 긴 증가하는 부분 수열은 적어도 하나의 원소를 공유해야만 한다. 따라서 M + K - 1보다 N이 작을 수 없다.

      - 부분 수열이 최대 길이 K를 가질 때, 전체 수열은 길이 K의 부분 수열 M개를 가져야하므로 N이 M과 K를 곱한 값보다 클 수 없다.

    - 위 조건을 만족하는 N에 대해서 1 ~ N의 전체 수열을 만든다. 적어도 하나의 부분 수열은 K개의 원소를 가져야 하므로 우선 slice를 통해 길이 K의 부분 수열을 만들어 결과에 저장한다.

    - 남은 수열은 길이 K를 넘지 않는 M - 1 개의 부분 수열로 나누어야 하기 때문에 M - 1개의 부분 수열의 길이를 저장할 array를 선언한다.

    - 남은 수열의 길이를 while문 내의 for문을 돌며 부분 수열의 길이 array에 적절히 분배한다.

    - 계산한 부분 수열의 길이만큼 남은 수열을 나누어 결과에 저장한다.

    - 각각의 부분 수열을 모두 뒤집어 출력한다.

### 추가 내용

- null

### 내일 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 3 문제 이상 풀 수 있는 만큼

### 앞으로 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 3 문제 이상 풀 수 있는 만큼

- SSAFY 코딩 테스트 대비 문제 풀이

- See See Call Call(계속)

  - 사용 중 불편한 점, Bug Fix

- 운동기록 웹앱 '삼대몇?(big3)' 제작(계속)

  - FEATURE records

  - FEATURE template

  - FEATURE settings

- Dream Coding 강의 보기

  - 브라우저 101

  - Git 마스터

  - 리액트

  - 타입스크립트

<br><br>
