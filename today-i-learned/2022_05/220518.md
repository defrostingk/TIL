# 2022. 05. 18. Wed

### 목차

- [오늘 한 일](#오늘-한-일)

- [진행하면서](#진행하면서)

- [추가 내용](#추가-내용)

- [내일 할 일](#내일-할-일)

- [앞으로 할 일](#앞으로-할-일)

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - brute force 1문제 풀이

- SSAFY 준비

  - swea d2 3문제 풀이

- 전화 면접

  - call by value vs call by reference

  - DFS vs BFS

  - overloading vs overriding

  - single thread vs multi thread

### 진행하면서

- 코딩 테스트 대비 문제 풀이(계속)

  - brute force 1문제 풀이

    - [연산자 끼워넣기 (2)](https://www.acmicpc.net/problem/15658)

      - DFS를 통해 가능한 경우의 수를 모두 탐색한다. 주어진 수열 사이사이에 연산자를 모두 사용했을 때 1번 탐색한 것으로 하고 최댓값과 최솟값을 갱신한다.

- SSAFY 준비

  - swea d2 3문제 풀이

    - 모두 2차원 배열을 선언하고 탐색하는 문제였다. 문제를 잘 읽고 내용을 누락하는 것 없이 따라가면 쉽게 풀이할 수 있었다.

- 전화 면접

### 추가 내용

- call by value vs call by reference

  - call by value

    call by value로 함수를 사용하면 함수 내부가 실행되며 parameter로 전달된 primitive type의 data를 다른 메모리 영역에 복사하여 저장한다. 함수 내부에서 어떤 동작을 하여 해당 parameter를 수정해도 함수 외부에 존재하는 해당 data에 변화가 없다.

  - call by reference

    call by reference로 함수를 사용하면 함수 내부에 전달되는 parameter는 어떤 data를 가리키는 reference, 메모리 주소의 복사값이다. 따라서 함수 내부에서 어떤 동작을 통해 전달된 parameter를 수정하면 해당 메모리 주소에 접근하여 동작하기 때문에 실제 메모리에 저장된 data가 수정된다.

- DFS vs BFS

  - DFS

    - graph에서 같은 방향으로 탐색 가능한 한 계속 탐색하고, 더 이상 탐색하지 못하면 다음 node에 대해 같은 방법으로 탐색을 반복하는 알고리즘이다.

    - 다음과 같이 stack을 사용해 구현할 수 있다.

      - 근접 node를 방문하면서 더이상 방문할 근접 node가 없을 때까지 stack에 방문한 node를 push한다.

        - 이때 방문한 node는 방문 여부를 저장하여 중복 방문이 일어나지 않도록 한다.

      - 더이상 방문할 근접 node가 없다면 방문할 근접 node가 생길 때까지 방문한 node를 pop한다.

    - 재귀 호출을 통해 구현할 수 있다.

      - 방문/재귀함수 호출/방문 상태 초기화를 반복하여 해당 경로에 대해 끝까지 탐색할 수 있다.

    - 탐색하면서 조건을 판단하는 등의 동작을 하기 좋다.

    - 장점

      - 찾고자 하는 node가 깊은 depth에 존재할 경우 비교적 빠르게 찾을 수 있다.

      - 해당 경로에 대해서만 탐색하므로 저장공간에 대한 부담이 BFS에 비해 적다.

      - 자기 자신으로 돌아오는 경로가 있는지 확인하는 것으로 사이클의 존재 여부를 판단할 수 있다.

    - 단점

      - 해가 없는 경로에 깊게 빠져 시간이 오래 걸릴 수 있다.

      - 한 방향으로 탐색하며 답을 찾으면 탐색을 중단하기 때문에 해당 답이 최단 경로인지 알 수 없다.

  - BFS

    - 한 node에서 탐색을 시작하여 주변 node를 우선하는 탐색을 반복하는 알고리즘이다.

    - 다음과 같이 queue를 활용해 구현할 수 있다.

      - 방문 node에 연결된 node를 모두 queue에 push한다.

      - node를 방문한 뒤 queue에 존재하는 node를 dequeue하여 방문하고 해당 node에 연결된 node를 모두 queue에 push한다.

      - 모든 node를 방문할 때까지, 즉 queue에 존재하는 node가 없을 때까지 이를 반복한다.

    - 장점

      - DFS와 달리 주변 모든 node에 대해 너비를 우선적으로 탐색하므로 해당 답이 최단 경로임을 알 수 있다.

        - 최단 경로를 구할 때 사용할 수 있다.

      - 해가 존재한다면 어느 경로가 무한히 깊어지더라도 해를 찾을 수 있다.

      - node 수가 적고 깊이가 얕은 해가 존재할 때 유리하다.

    - 단점

      - 방문 가능한 주변 node를 모두 저장하여 사용하기 때문에 저장공간에 대한 부담이 DFS보다 크다.

- overloading vs overriding

  - overloading

    parameter 개수나 타입이 다른, 같은 이름의 함수를 여러 번 정의하여 호출할 때 해당 parameter에 적합한 함수를 호출한다. JavaScript에서는 제공하지 않으나, 함수 내부에서 parameter에 대해 조건문을 사용하거나 arguments에 조건문을 사용하는 것으로 비슷한 동작을 할 수 있다.

  - overriding

    부모 클래스에서 자식 클래스로 특정 method를 상속했을 때, 자식 클래스에서 해당 method를 재정의하여 사용하는 것을 말한다. call(this)를 사용해 부모 함수의 기능을 그대로 이어받아 내용을 추가할 수도 있고 새롭게 재정의할 수도 있다. 하지만 반환값은 부모 클래스의 method와 동일하여야 한다.

- single thread vs multi thread

  - 프로그램이 실행되면 메모리를 공간을 할당받아 프로세스가 된다. 이때 Code, Data, Stack, Heap의 형태로 메모리를 할당한다. 각각의 프로세스에 독립된 메모리 영역을 할당하기 때문에 다른 프로세스의 변수나 자료에 접근할 수 없다. 프로세스 내부에서 동작하는 더 작은 실행 단위가 스레드이고 각각 별도의 Stack을 가진다. Code, Data, Stack, Heap은 스레드끼리 공유한다.

  - single thread

    - 하나의 프로세스에서 하나의 스레드를 실행한다. 즉 하나의 레지스터와 스택으로 표현한다.

    - 장점

      - 위에서 스레드끼리 Code, Data, Stack을 공유한다 했는데, 이것과 같은 자원 접근에 대해 동기화를 신경쓰지 않아도 된다.

        - 여러 개의 스레드가 공유된 자원을 사용할 경우, 각 스레드가 정상적으로 동작하게 하려면 공용 자원에 대한 접근을 통제해야 한다. 이 작업은 프로그래머에게 많은 노력과 비용을 요구한다. 하지만 단일 스레드의 경우 신경쓰지 않아도 된다.

        - 따라서 여러 개의 프로세스가 하나의 프로세서를 공유할 때 발생하는 작업 전환을 요구하지 않는다.

      - 두 개의 작업을 하나의 스레드로 처리하는 경우와 두 개의 스레드로 처리하는 경우를 가정한다. 멀티 스레드의 경우 짧은 시간 동안 2개의 스레드가 번갈아가며 동작한다. 이것은 동시에 두 작업이 처리되는 것처럼 보인다. 하지만 오히려 두 개의 스레드로 작업한 시간이 싱글 스레드로 작업한 시간보다 더 소요될 수 있는데, 스레드 간의 작업 전환에 시간이 걸리기 때문이다.

        따라서 단순 CPU만을 사용하는 계산 작업이라면 멀티스레드보다 싱글스레드를 사용하는 것이 효율적이다.

    - 단점

      - 여러 개의 CPU를 활용하지 못한다.

        - 프로세서를 최대한 활용하기 위해 여러 개의 프로그램 인스턴스를 실행시키거나 cluster 모듈을 사용해 여러 개의 CPU를 사용할 수 있다.

  - multi thread

    - 하나의 프로세스에서 여러 개의 스레드를 실행한다. 각각의 스레드는 고유의 레지스터와 스택으로 표현한다.

    - 프로그램을 다수의 실행 단위로 나누어 실행한다.

    - 프로세스 내에서 자원을 공유하기 때문에 자원 생성과 관리의 중복이 최소화된다.

    - 서버가 많은 요청을 효율적으로 수행할 수 있도록 한다.

    - 장점

      - 새로운 프로세스를 생성하는 것보다 기존 프로세스에서 스레드를 생성하는 것이 빠르다.

      - 프로세스의 자원과 상태를 공류하여 효율적으로 운영이 가능하다.

      - 프로세스 사이의 작업 전환보다 스레드의 작업 전환이 더 빠르다.

    - 단점

      - 싱글 코어의 멀티 스레딩은 스레드 생성 시간 때문에 단일 스레드보다 느리다.

      - 멀티 스레딩을 위해 운영체제의 지원이 필요하다.

        - MS-DOS와 같은 초기 운영체제를 제외하고는 대부분 지원한다.

      - 스레드끼리 같은 자원을 공유하기 때문에 이를 동기화 할 스레드 스케쥴링을 신경 써야 한다.

### 내일 할 일

- 기본 일과

  - 1일 1 코테

  - 1일 1 자바스크립트 딥다이브

  - 1일 1 CS

  - 1주일 1(월~일) 인성면접 & 자소서 문항

- SSAFY 준비

  - swea 문제 풀이(계속)

  - SSAFY 에세이 작성

### 앞으로 할 일

- 기본 일과

  - 1일 1 코테

  - 1일 1 자바스크립트 딥다이브

  - 1일 1 CS

  - 1주일 1(월~일) 인성면접 & 자소서 문항

- SSAFY 준비

  - swea 문제 풀이(계속)

  - SSAFY 에세이 작성

- 우아한 테크캠프 준비

- See See Call Call(계속)

- 운동기록 웹앱 '삼대몇?(big3)' 제작(계속)

  - FEATURE template

  - FEATURE settings

- Dream Coding 강의 보기

  - Git 마스터

  - 리액트

  - 타입스크립트

<br><br>
