# 2022. 03. 28. Mon

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - graph 1문제 풀이

- zoom 클론 코딩(계속)

  - 사용 중 불편한 점, Bug Fix

- Dream Coding 강의 보기

  - 자바스크립트 마스터리 (ES6+ 최신 문법)

    - JavaScript의 역사

    - 변수

    - 연산자(계속)

### 진행하면서

- graph 1문제 풀이

  - 첫 grpah 문제를 풀이하였다. 처음 풀이하는 유형의 문제라 오래 고민하지 않고 다른 사람의 아이디어를 참고하였다. 첫 풀이에는 adjacency matrix를 사용하였다. 모든 node에 대하여 연결 상태를 2차원 배열로 표현하는 방법이다. 예를 들어 0-4의 5개의 node가 존재하고 0-1, 1-2, 2-3, 3-4 가 연결되어 있을 때 adjacency matrix는 다음과 같이 표현한다.

    ```
            0   1   2   3   4
         _____________________
    0   |   0   1   0   0   0
    1   |   1   0   1   0   0
    2   |   0   1   0   1   0
    3   |   0   0   1   0   1
    4   |   0   0   0   1   0
    ```

    각 node로부터 연결되어 있는 node에 대해서만 dfs로 탐색하였다. 구현은 맞은 것 같지만 시간초과로 실패하였다. 각 node에서 다음 node로 탐색하는 과정에서 모든 node를 살펴야하기 때문에 일어난 시간초과라고 생각한다.

    - 다음 풀이에 adjacency list를 사용하였다. 모든 node에 대하여 연결되어 있는 node만 list에 넣어 표현한다. 위와 같은 예에서 adjacency list는 다음과 같이 표현한다.

      ```
      0 |   1
      1 |   0   2
      2 |   1   3
      3 |   2   4
      4 |   3
      ```

      각 node에서 다음 node로 탐색하는 과정에서 살펴야 하는 node의 수가 줄어들기 때문에, 연결되어 있는 node만 살피기 때문에 탐색하는 시간이 줄어들었다.

- 자바스크립트 마스터리 (ES6+ 최신 문법)

  - Nomad Coder의 clone coding 강의는 pug, express, babel, AWS, Heroku 등 여러 가지를 경험하며 배우기에는 좋았지만 JavaScript의 구조나 작동 과정과 같이 기본적인 내용이 부족하다고 느꼈다. 나중에 면접에서 JavaScript 자체에 대한 질문을 받는다면 대답할 자신이 없었다. 그러던 중 접하게 된 것이 Dream Coding의 강의였다. 이 강의를 통해서라면 실제 메모리의 구조나 데이터의 접근 방법 등 JavaScript의 동작에 대해 배울 수 있다고 생각했다. 또한 지금까지 구현을 통해 JavaScript를 배워왔기 때문에 기본을 다질 수 있는 이론 강의도 필요하다 생각하던 참이었다. 용어를 몰라서 검색이 힘든 경우도 있었다. 오늘은 JavaScript의 역사와 변수에 대해 작은 영역만을 배웠지만, 시작하기 참 잘했다는 생각이 들었다. 구현 시 안됐던 부분을 원래 안되는 것이라 그냥 받아들일 때도 있었는데, 벌써 그것에 대한 의문이 풀렸다.

  - 첫번째로 배열의 복사에 대한 것이었다. 코딩테스트 대비를 위해 문제를 풀 때였다. 배열을 담은 변수를 다른 변수에 그대로 대입했더니 복사가 제대로 이루어지지 않았다. 어느 한 쪽을 변경하면 둘 다 변경이 되었다. 결국 for문을 사용하여 원소 하나하나에 접근하여 값을 대입하자 제대로 복사가 이루어졌다. 하지만 이 방법도 만약 배열 내에 배열이 존재하는 경우, 제대로 복사가 이루어지지 않았다. 그때는 배열 내에 배열을 넣지 않은 경우로도 풀이가 가능했기 때문에 구조를 바꾸어 배열 내에 배열이 들어간 형태를 사용하지 않고 풀이했다.

    - 배열의 형태를 하고있지만 본질은 object인데, JavaScript에서 Object를 담은 variable은 해당 object를 담고 있는 memory(heap)의 시작 주소를 가리키고 있을뿐이다. 따라서 object를 담은 변수를 다른 변수에 대입하여도 그 변수도 주소값을 가리킨다. 당연히 어느 한 쪽의 object의 내용이 변경이 되면 다른 한 쪽도 변경이 일어나는 것이었다. 단지 주소값만을 가리키고 있기 때문이다. object 내의 요소에 직접 접근하여 대입하지 않는 이상 새로운 object로 복사가 이루어지지 않는다.

    - 배열 내 배열이 있는 경우도 같은 이유에서였다. 가장 바깥의 배열에서, 배열 내부 요소에 접근한다한들, 그 요소도 주소값만을 가리키고 있기 때문이었다. 그 요소의 내부 요소에 접근해야 실제 값이 변경되는 것이다. 즉 object 내의 primitive type value를 담은 요소에 접근해야 한다.

    - primitive type value를 변수에 담을 경우, 변수명이 memory 주소이고, 그 변수는 memory 내의 값을 직접 가리킨다. 값은 memory내의 data, stack 영역에 저장된다.

    - object type value를 변수에 담을 경우, 변수명이 memory 주소이고, 그 변수는 object가 담긴 memory(heap)의 시작 주소를 가리킨다. 이 주소값은 data, stack 영역에 저장되고, object의 실제 내용은 heap 영역에 저장된다.

  - string 입력 시 사용하던 ``의 이름은 Template Literal 이었다.

  - 변수나 값 앞에 !! 연산자를 붙여 boolean 값으로 return할 수 있다.

  - NaN은 false이다. Infinity는 true이다.

  - undefined는 진짜 비어있는것을 나타낸다.

  - null은 비어있는 것을 알리는 object값(null)이 들어있다. 완전히 비어있는 것이 아니다.

### 추가 내용

-

### 내일 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- zoom 클론 코딩(계속)

  - 사용 중 불편한 점, Bug Fix

- Dream Coding 강의 보기

  - 자바스크립트 마스터리 (ES6+ 최신 문법)

### 앞으로 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- zoom 클론 코딩(계속)

  - 사용 중 불편한 점, Bug Fix

- Dream Coding 강의 보기

  - 자바스크립트 마스터리 (ES6+ 최신 문법)

  - 엘리의 포트폴리오 웹사이트 클론 코딩

<br><br>
