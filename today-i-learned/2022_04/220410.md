# 2022. 04. 10. Sun

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - graph 1문제 풀이

### 진행하면서

- graph 1문제 풀이

  - 인접한 node들을 섬이라는 group으로 지정하고, 각 group 간의 최소 거리를 구하는 문제였다. 처음 BFS를 통해 섬을 구분하고, 그 섬의 모든 node에 대해서 다른 섬까지의 거리를 다시 BFS로 구하면 된다고 생각했다. 즉 크게 3단계가 필요하다.

    0. 섬에 해당하며 방문하지 않은 모든 node에 대해

    1. BFS를 사용하여 섬 하나를 특정한다.

    2. 그 섬의 모든 node로부터 다른 섬에 해당하는 node까지의 거리를 계산하여 저장한다.

       - 시작 node를 저장하고, 도착했을 때 node를 저장하여 시작부터 탐색 종료까지 걸린 depth를 계산한다.

       - 다시 1. 로 돌아가 다른 섬을 특정한다.

    3. 그 거리 중 최솟값을 구한다.

    하지만 이 방법은 섬 하나를 특정하는 과정에서 불필요한 반복이 일어났다. 또한 2. 에서 모든 node로부터 거리를 구하기 때문에 섬 node만큼의 BFS가 반복되어야 했다. 구현에는 성공하였으나, 메모리(44552KB)와 시간(908ms)의 소요가 컸다.

  - 따라서 다른 방법을 생각해야 했다. 다음으로 생각한 방법은 섬에 해당하며 방문하지 않은 모든 node에 대해 BFS를 사용하여 각 섬을 특정하고, 그 섬의 node에 대해 BFS를 단 1회 사용하여 경계를 구분 짓는 것이었다. 이후 경계까지의 거리를 구하여 최솟값을 구했다. 다음과 같이 구현할 수 있다.

    0. 섬에 해당하며 방문하지 않은 모든 node에 대해

    1. BFS를 사용하여 각 섬을 특정짓는다. 배열 1에 그 정보를 저장한다.

       -섬1은 '1', 섬2는 '2', ...

    2. 특정한 섬의 node를 모두 queue에 넣고 BFS를 사용하여 남은 공간을 채운다. 각 탐색에 depth를 세어 배열 2에 저장한다. 동시에 배열 1에 섬을 확장시킨다.

    - 각 섬의 node로부터 탐색을 시작하므로, 섬1에서 시작한 탐색인지 섬2에서 시작한 탐색인지 저장할 수 있다.

    3. 배열 1의 모든 node를 돌며 인접한 node가 다른 섬에 속해있을 경우, 배열 2의 depth 정보를 이용하여 두 섬으로부터의 거리를 계산하여 저장한다.

       - 섬1에서 뻗어나온 node와 섬2에서 뻗어나온 node가 인접했을 경우, 섬1에서 해당 node까지의 depth와 섬2에서 해당 node까지의 depth의 합에서 2를 빼면 거리가 된다.

    4. 그 거리 중 최솟값을 구한다.

  - 개선된 알고리즘은, 섬의 개수만큼 BFS를 실행한 뒤 단 1회 BFS를 실행한다. 그 후 전체 node를 돌며 거리를 구한다. 처음 구현한 알고리즘은 섬의 node 수만큼 BFS를 실행하였기 때문에 비효율적이고 느렸다. 하지만 다시 구현한 코드는 메모리(44552KB->17152KB)와 시간(908ms->260ms)의 소요가 큰 폭으로 줄어들었다.

### 추가 내용

- null

### 내일 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- Dream Coding 강의 보기

  - 엘리의 포트폴리오 웹사이트 클론 코딩(계속)

### 앞으로 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- zoom 클론 코딩(계속)

  - 사용 중 불편한 점, Bug Fix

  - README.md 작성

  - 나만의 영상채팅앱으로 수정

- 운동기록 웹앱 '삼대몇?(big3)' 제작

- Dream Coding 강의 보기

  - 엘리의 포트폴리오 웹사이트 클론 코딩

  - 브라우저 101

  - Git 마스터

  - 리액트

  - 타입스크립트

<br><br>
