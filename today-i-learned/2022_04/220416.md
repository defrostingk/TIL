# 2022. 04. 16. Sat

### 목차

- [오늘 한 일](###오늘-한-일)

- [진행하면서](###진행하면서)

- [추가 내용](###추가-내용)

- [내일 할 일](###내일-할-일)

- [앞으로 할 일](###앞으로-할-일)

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - tree 1문제 풀이

- SSAFY 대비하여 코딩 테스트 대비 문제 python으로 재풀이(계속)

  - data structure 1문제 python으로 재풀이

### 진행하면서

- tree 1문제 풀이

  - [트리 순회](https://www.acmicpc.net/problem/1991)

  - tree 형태의 graph를 BFS나 DFS로 탐색하는 문제는 풀어보았지만, 전위(preorder), 중위(inorder), 후위(postorder)로 순회(traversal)하는 것은 처음이었다. 개념도 생소하여 각각의 순회를 이해하는 것도 힘들었다. 문제에서 방문 방식을 설명해주었지만, 다시 내 언어로 풀어서 설명해야 이해가 갔다. 다음과 같은 tree가 존재한다고 가정한다.

    ![image](https://user-images.githubusercontent.com/95136896/163672647-7f46c92f-bc83-4074-94d8-19ea60d583a4.png)

    - 전위 // (루트) (왼쪽 자식) (오른쪽 자식)

      - 루트(A)를 방문하고, 왼쪽 자식(B)을 방문한다. 다시 그 자식의 왼쪽 자식(D), 오른쪽 자식(없음) 순으로 방문한다. 자식이 없을 때까지 방문하고, 방문했던 부모들의 오른쪽 자식(없음)을 모두 방문한다. 최상위 노드(A)에서 오른쪽 자식(C)을 방문한다. 그 자식(C)의 왼쪽 자식(E)을 방문한다. 오른쪽 자식(F)을 방문하고 그 자식(F)의 왼쪽 자식(없음), 오른쪽 자식(G)을 방문한다. 순서대로 정렬하면 ABDCEFG이다.

    - 중위 // (왼쪽 자식) (루트) (오른쪽 자식)

      - 루트(A)의 왼쪽 자식(B)의 왼쪽 자식의(D).. 자식이 없을 때까지 왼쪽 자식의 끝(D)으로 내려간다. 그 왼쪽 자식의 끝(D)을 방문하고, 부모(B)를 방문한다. 최상위 노드(A)까지 반복한다. 최상위 노드인 루트(A)를 반복하고 오른쪽 자식(C)의 왼쪽 노드(E)를 방문한다. 그 부모(C)를 방문하고, 오른쪽 자식(F)의 왼쪽 자식(없음), 부모(F: 왼쪽 자식(없음)의 부모)를 방문한다. 그(F) 오른쪽 자식(G)를 방문한다. 순서대로 정렬하면 DBAECFG이다.

    - 후위 // (왼쪽 자식) (오른쪽 자식) (루트)

      - 중위와 마찬가지로 왼쪽 자식의 끝(D)로 내려간다. 그 끝(D)를 방문하고 부모(B)를 방문하고 최상위 노드(A)까지 올라간다. 루트(A)의 오른쪽 자식(C)의 왼쪽 자식(E)를 방문하고, 부모(C)의 오른쪽 자식(F)로 내려간다. 그 자식(F)의 왼쪽 자식(없음)을 확인하고, 오른쪽 자식(G)로 내려간다. 더이상 자식이 없는 끝이므로 끝(G)를 방문하고, 그 부모(F)를 방문하고, 그 부모(C)를 방문하고, 그 부모이자 루트(A)를 방문한다. 순서대로 정렬하면 DBEGFCA이다.

  - 각각의 순회를 이해했음에도 구현할 좋은 아이디어가 떠오르지 않아 다른 사람의 아이디어를 참고하였다. 재귀를 사용하면 쉽게 구현할 수 있었다.

  - 예를들어 전위 순회의 경우 재귀함수의 인자로 루트 노드를 받고 방문 순서를 저장했다. 그 후 재귀적으로 왼쪽 자식, 오른쪽 자식 노드를 탐색해갔다.

    ```JavaScript
    const tree = {
      A: ['B', 'C'],
      B: ['D', '.'],
      C: ['E', 'F'],
      E: ['.', '.'],
      F: ['.', 'G'],
      D: ['.', '.'],
      G: ['.', '.'],
    };

    let result = "";

    function preorder(node) {
        if (node === '.') return;
        const [left, right] = tree[node];
        result += node;
        preorder(left);
        preorder(right);
      }

    preorder('A');
    console.log(result); // ABDCEFG
    ```

  - 중위 순회의 경우 왼쪽 자식, 루트, 오른쪽 자식 순으로 방문하므로 왼쪽 자식을 탐색하고, 방문 순서를 저장하고, 오른쪽 자식을 탐색했다.

  - 후위 순회의 경우 왼쪽 자식, 오른쪽 자식, 루트 순으로 방문하므로 왼쪽 자식을 탐색하고, 오른쪽 자식을 탐색하고, 방문 순서를 저장하였다.

- data structure 1문제 python으로 재풀이

  - [스택](https://www.acmicpc.net/problem/10828)

  - list 관련 method를 활용해 간편하게 stack처럼 사용할 수 있었다.

  - 내용이 있는 list의 boolean값은 true이고, 내용이 없는 list의 boolean값은 false이다.

  - 여러줄의 text input을 open으로 받아와 for문에 사용하면 다음과 같이 한 줄씩 받아올 수 있다.

    ```python
    file_input = open('file_path', 'r')

    for line in file_input:
        print(line)
    ```

### 추가 내용

- open

  - open 함수는 해당 path에 존재하는 file을 여는 함수이다. text file인 경우 io.TextIOWrapper라는 클래스 객체를 생성한다. 따라서 for문으로 해당 반환값을 loop하면 위처럼 한 줄씩 받아올 수 있다. 다만 print되는 값을 보아 각 줄의 맨 뒤에 입력된 개행문자 '\n'도 함께 받아오는 것을 확인할 수 있다.

  - 첫번째 인자로 file path를 받고, 두번째 인자로 mode를 받는다. mode는 다음과 같다. 'r', 'w', 'a'에 '+'를 붙여 읽기/쓰기, 쓰기/읽기, 추가/읽기 mode로 파일을 열 수도 있다.

    - 'r': 기본값, 읽기 모드로 파일을 연다.

    - 'w': 쓰기 모드로 파일을 연다. 파일이 존재하지 않는다면 새롭게 파일을 생성하지만, 파일이 존재한다면 내용을 덮어쓴다.

    - 'a': 쓰기(추가) 모드로 파일을 연다. 'w' mode와 다른 점은 이미 파일이 존재할 때 내용을 작성하면 이미 작성된 내용 뒤에 추가된다.

    - 'x': 파일이 없으면 파일을 생성하고, 쓰기 모드 'w'로 연다. 파일이 있으면 에러가 발생한다.

  - 위 4개 mode에 아래 2개 mode를 붙여서 사용할 수 있다.

    - 'b': binary mode로 파일을 연다.

    - 't': text mode로 파일을 연다. 기본값

### 내일 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1 ~ 3문제

- 운동기록 웹앱 '삼대몇?(big3)' 제작

### 앞으로 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1 ~ 3문제

- SSAFY 대비하여 코딩 테스트 대비 문제 재풀이(계속)

  - 1 ~ 3문제

- See See Call Call(계속)

  - 사용 중 불편한 점, Bug Fix

- 운동기록 웹앱 '삼대몇?(big3)' 제작

- Dream Coding 강의 보기

  - 브라우저 101

  - Git 마스터

  - 리액트

  - 타입스크립트

<br><br>
