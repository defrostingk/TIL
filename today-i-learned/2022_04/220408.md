# 2022. 04. 08. Fri

### 오늘 한 일

- 코딩 테스트 대비 문제 풀이(계속)

  - graph 1문제 풀이

### 진행하면서

- graph 1문제 풀이

  - 너무 끔찍했다. 주어진 graph에서의 BFS 방문 순서가 옳은 지 판별하는 문제였다. BFS에서 다음 depth의 node들을 방문할 때 node의 순서는 중요하지 않아 여러가지의 결과를 가질 수 있다. 주어진 방문 순서가 여러가지 결과 내에 포함되는지 알아내야했다.

  - 처음에는 BFS 방식으로 방문하여 depth를 저장하고 주어진 순서의 depth를 비교하였다. node들이 같은 depth 내에 있으면 올바른 방문 순서라 판단했다. 하지만, parents node의 방문 순서에 따라 child node의 방문 순서가 달라지는 것을 간과하였다. 예를 들어 다음과 같은 그래프가 존재할 때, BFS 방식으로 방문한 결과 중 하나는 1 2 3 4 5 6 7이다.

    ```
    1 - 2 - 4
          - 5
      - 3 - 6
          - 7
    ```

    만약 1 3 2 4 5 6 7 순으로 방문한다면 위 방문 결과와 비교했을때 각 node의 depth는 동일하다. 하지만 먼저 방문한 parents node의 child node부터 방문해야하므로, 올바른 순서는 1 3 2 6 7 4 5 이다. 이러한 반례를 찾을 수 있었다.

  - 다음으로는 주어진 방문 결과의 순서대로 adjacency list의 정렬 순서를 변경하였다. BFS 방식을 사용할 때 adjacency list의 정렬 순서대로 queue에 push하여 방문하였다. 따라서 방문 결과의 순서대로 adjacency list를 정렬한다면, 그때의 올바른 BFS 방문 순서를 얻을 수 있다. 이렇게 얻은 방문 순서와 주어진 방문 순서를 비교하여 주어진 방문 순서가 올바른지 판단할 수 있다. 일련의 과정은 다음과 같은 순서로 이루어진다.

    0. 주어진 방문 순서가 1로 시작하지 않을 경우 0을 return하고 출력한다.

       (문제에서 주어진 조건)

    1. 주어진 edge 정보를 이용하여 adjacency list를 얻는다.

    2. 주어진 방문 순서를 토대로 각 node의 방문 순서를 저장한다.

    3. 저장한 node의 방문 순서를 이용해 adjacency list 내 정렬 순서를 변경한다. 먼저 방문한 node가 앞으로 오도록 오름차순으로 정렬한다.

    4. 정렬한 adjacency list를 사용해 올바른 BFS 방문 순서를 얻는다.

    5. 올바른 BFS 방문 순서와 주어진 방문 순서를 비교하여 같으면 1, 다르면 0을 return하고 출력한다.

### 추가 내용

- null

### 내일 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- Dream Coding 강의 보기

  - 엘리의 포트폴리오 웹사이트 클론 코딩(계속)

### 앞으로 할 일

- 코딩 테스트 대비 문제 풀이(계속)

  - 1~3문제

- zoom 클론 코딩(계속)

  - 사용 중 불편한 점, Bug Fix

  - README.md 작성

  - 나만의 영상채팅앱으로 수정

- 운동기록 웹앱 '삼대몇?(big3)' 제작

- Dream Coding 강의 보기

  - 엘리의 포트폴리오 웹사이트 클론 코딩

  - 브라우저 101

  - Git 마스터

  - 리액트

  - 타입스크립트

<br><br>
